import requests
import re
import sys
import urllib3 # Used to suppress InsecureRequestWarning

# Suppress warnings generated by verify=False
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# Define the security-critical PHP directives and headers we want to check
CRITICAL_DIRECTIVES = [
    "allow_url_fopen",
    "allow_url_include",
    "register_argc_argv",
    "file_uploads",
    "session.upload_progress.enabled",
    "disable_functions",
    "open_basedir",
    "session.save_path",
    "auto_prepend_file",
]

def _parse_version(version_str):
    """Safely parses a version string (e.g., '5.2.9-2') into a list of integers."""
    # Use regex to strip any trailing non-numeric characters (like '-2' or '+dfsg') 
    # This prevents the int() conversion error when parsing distribution-specific versions.
    clean_version = re.sub(r'[^0-9\.].*$', '', version_str)
    
    try:
        return [int(x) for x in clean_version.split('.')]
    except:
        return []

def _get_value(content, directive, is_general_info=False):
    """
    Extracts the local value for a PHP directive or general info (like Server API or System)
    from the phpinfo HTML content.
    """
    if is_general_info:
        # HIGHLY ROBUST match for two-column general info (e.g., Server API, System)
        # Finds the directive label, consumes any HTML until the next <td>, and captures its content.
        # This handles arbitrary whitespace and tag attributes between the label and value cells.
        pattern = re.compile(
            r'<tr>\s*<td[^>]*>(?:\s*|&nbsp;)*{}[\s\S]*?<\/td>\s*<td[^>]*>(.+?)<\/td>.*?<\/tr>'.format(re.escape(directive)), 
            re.DOTALL | re.IGNORECASE
        )
    else:
        # Standard match for three-column directives (local value column, which typically uses class="v")
        pattern = re.compile(r'<tr><td class="e">{}<\/td>.*?<td class="v">(.+?)<\/td>.*?<\/tr>'.format(re.escape(directive)), re.DOTALL | re.IGNORECASE)

    match = pattern.search(content)
    if match:
        raw_value = match.group(1).strip().replace('\n', '').replace('\r', '')
        # Sanitize HTML output (removes any nested tags inside the value cell)
        clean_value = re.sub(r'<[^>]+>', '', raw_value).strip()
        return clean_value if clean_value.lower() not in ('no value', 'none', '') else "None (Default)"
    return "Not Found"

def _get_php_version_from_html(content):
    """Extracts the PHP version string from the phpinfo HTML content."""
    match = re.search(r'<h1 class="p">PHP Version ([\d\.]+)<\/h1>', content, re.DOTALL | re.IGNORECASE)
    return match.group(1).strip() if match else "Not Found"

def _get_version_from_headers(headers):
    """Extracts PHP version from HTTP headers (X-Powered-By)."""
    powered_by = headers.get('X-Powered-By')
    if powered_by and 'PHP/' in powered_by:
        match = re.search(r'PHP/([\d\.]+)', powered_by)
        if match:
            return match.group(1).strip(), "X-Powered-By Header"
    return "Not Found", None

def _is_running_in_docker(content):
    """
    Heuristic check for Docker container environment by looking for a container ID.
    The container short ID (12-char hex string) often appears as the HOSTNAME 
    environment variable dumped by phpinfo.
    """
    # Check 1: Look for HOSTNAME environment variable containing a 12-char hex string
    # This pattern specifically searches the environment variable dump (often in a dedicated table)
    # for the HOSTNAME key and a 12-character hex value.
    if re.search(r'HOSTNAME.*?<td[^>]*>([0-9a-f]{12})<\/td>', content, re.DOTALL | re.IGNORECASE):
        return True
    
    # Check 2: Fallback to the common PHP_INI_DIR path heuristic
    if re.search(r'<td>PHP_INI_DIR<\/td>.*?<td>\/usr\/local\/etc\/php<\/td>', content, re.DOTALL | re.IGNORECASE):
        return True

    # Check 3: Check for generic server software names often used in containers (e.g., FPM)
    server_software = _get_value(content, "Server Software", is_general_info=True)
    if "fpm" in server_software.lower():
        return True
        
    return False

def _check_windows_platform(content):
    """
    Checks if the operating system indicates Windows, first via the 'System'
    field, then via common file path patterns as a fallback.
    Returns True if Windows is detected, False otherwise.
    """
    os_str = _get_value(content, "System", is_general_info=True)
    
    # 1. Primary check: 'System' field contains 'Windows' or 'WinNT'
    if 'win' in os_str.lower():
        return True

    # 2. Fallback check: Look for tell-tale Windows paths (drive letters or backslashes)
    # Check these common path-related directives
    path_directives = ["extension_dir", "include_path", "session.save_path"]
    
    for directive in path_directives:
        path_value = _get_value(content, directive)
        # Check for drive letter (C:\) or the Windows path separator (\)
        if re.search(r'[a-zA-Z]:\\|\\', path_value):
             return True
             
    return False

def _check_cve_2012_1823(php_version, server_api):
    """Checks the specific version ranges for the original CGI RCE vulnerability (CVE-2012-1823)."""
    if server_api not in ['CGI', 'FastCGI', 'CGI/FastCGI']:
        return None

    parsed_version = _parse_version(php_version)
    # Require at least major.minor to proceed
    if len(parsed_version) < 2: 
        return None

    major, minor = parsed_version[:2]
    # Use 0 if patch version is missing (e.g. 5.2)
    patch = parsed_version[2] if len(parsed_version) >= 3 else 0

    # Check PHP before 5.3.12 (covers 5.0.x, 5.1.x, 5.2.x, and 5.3.x < 5.3.12)
    if (major < 5) or \
       (major == 5 and minor < 3) or \
       (major == 5 and minor == 3 and patch < 12):
        return "!!! CRITICAL: CVE-2012-1823 RCE via CGI mode and PHP version is < 5.3.12."

    # Check 5.4.x before 5.4.2
    if major == 5 and minor == 4 and patch < 2:
        return "!!! CRITICAL: CVE-2012-1823 RCE via CGI mode and PHP version < 5.4.2."
    
    return None

def _check_cve_2024_4577(php_version, is_windows):
    """Checks the specific version ranges for the Windows RCE vulnerability (CVE-2024-4577)."""
    if not is_windows:
        return None
    
    parsed_version = _parse_version(php_version)
    if len(parsed_version) < 3:
        return None

    major, minor, patch = parsed_version[:3]
    
    # PHP 8.3 < 8.3.8
    if major == 8 and minor == 3 and patch < 8:
        return "!!! CRITICAL: CVE-2024-4577 RCE (Argument Injection) on Windows."

    # PHP 8.2 < 8.2.20
    if major == 8 and minor == 2 and patch < 20:
        return "!!! CRITICAL: CVE-2024-4577 RCE (Argument Injection) on Windows."
        
    # PHP 8.1 < 8.1.29
    if major == 8 and minor == 1 and patch < 29:
        return "!!! CRITICAL: CVE-2024-4577 RCE (Argument Injection) on Windows."
        
    return None


def fetch_and_analyze_phpinfo(url):
    """Main function to fetch and perform advanced analysis."""
    print(f"[*] Starting advanced recon on {url} (Ignoring SSL Certificate Errors)...")
    try:
        # Use verify=False to ignore SSL certificate issues
        response = requests.get(url, timeout=15, verify=False) 
        response.raise_for_status()
    except requests.exceptions.RequestException as e:
        print(f"[-] Error accessing URL: {e}")
        return

    content = response.text
    print(f"[+] Successfully fetched {len(content)} bytes of configuration data.")

    # 1. Gather all necessary configuration values
    config = {}
    for directive in CRITICAL_DIRECTIVES:
        config[directive.lower()] = _get_value(content, directive)

    server_api = _get_value(content, "Server API", is_general_info=True)
    server_software = _get_value(content, "Server Software", is_general_info=True) # HTML value
    server_header = response.headers.get('Server', 'Not Found').lower()

    # Determine if Apache is running (Header priority)
    is_apache = 'apache' in server_header or 'apache/' in server_software.lower()

    # Attempt to get PHP version from headers first
    php_version, version_source = _get_version_from_headers(response.headers)
    
    # Fallback to HTML parsing if header check fails
    if version_source is None or php_version == "Not Found":
        php_version = _get_php_version_from_html(content)
        version_source = "PHPINFO HTML" if php_version != "Not Found" else "None"
        
    is_docker = _is_running_in_docker(content)
    is_windows = _check_windows_platform(content) 
    
    # Get OS info for printing
    os_info = _get_value(content, "System", is_general_info=True) 
    os_status_message = "Windows (Confirmed via Path)" if is_windows and 'win' not in os_info.lower() else os_info

    # Refine Server Software display based on header
    server_software_display = server_software
    if server_header != 'not found':
        server_software_display += f" (Header: {server_header.upper()})"


    print("\n--- Environment and Core Configuration ---")
    print(f"[Server API]        : {server_api}")
    print(f"[Server Software]   : {server_software_display}")
    print(f"[PHP Version]       : {php_version} (Source: {version_source})")
    print(f"[Operating System]  : {os_status_message}")
    print(f"[Running in Docker?] : {'YES' if is_docker else 'NO (Heuristic)'}")
    print("-" * 40)


    print("\n--- Vulnerability Analysis ---")
    found_vulnerabilities = False

    # Check 1: CVE-2012-1823 (Original CGI RCE)
    cve_result_1823 = _check_cve_2012_1823(php_version, server_api)
    if cve_result_1823:
        print(f"[VULNERABILITY] {cve_result_1823}")
        found_vulnerabilities = True

    # Check 1b: CVE-2024-4577 (Windows Argument Injection)
    cve_result_4577 = _check_cve_2024_4577(php_version, is_windows)
    if cve_result_4577:
        print(f"[VULNERABILITY] {cve_result_4577}")
        found_vulnerabilities = True
        
    # Check RCE Primary (Disable Functions)
    if config['disable_functions'] == "None (Default)":
        print(f"[EXPLOIT PATH] **Straightforward RCE via system()/exec()/shell_exec() is possible.** (disable_functions is empty)")
        found_vulnerabilities = True
    elif 'system' in config['disable_functions'].lower() and 'exec' in config['disable_functions'].lower():
        # Only print this if core RCE functions are blocked, pointing to the need for bypasses
         print(f"[BYPASS REQUIRED] Core RCE functions (system/exec) are blocked. Check advanced bypasses below.")


    # Check 2 & 3: pearcmd.php RCE Bypass
    if config['register_argc_argv'].lower() == 'on':
        
        if is_docker:
            # Check 2: Docker + register_argc_argv
            print("  [EXPLOIT PATH] Docker + register_argc_argv enabled. **RCE via LFI + pearcmd.php is highly likely (requires LFI parameter).**")
            found_vulnerabilities = True

            # Check 3: Apache + CRLF technique
            if is_apache: # Checks header first, then HTML content
                print("  [ADVANCED EXPLOIT] Apache detected. **CRLF injection via LFI may also exploit pearcmd.php.**")
                found_vulnerabilities = True

    # Check 4: Upload Race Condition
    if config['file_uploads'].lower() == 'on':
        print(f"[EXPLOIT PATH] file_uploads is ENABLED. **RCE via upload race condition is possible (requires LFI parameter).**")
        found_vulnerabilities = True

    # Check 5: Session Upload Progress
    if config['session.upload_progress.enabled'].lower() == 'on':
        print(f"[EXPLOIT PATH] session.upload_progress.enabled is ENABLED. **RCE via session upload progress handler is possible (requires LFI parameter).**")
        found_vulnerabilities = True

    # Check 6: SSRF
    if config['allow_url_fopen'].lower() == 'on':
        print(f"[EXPLOIT PATH] allow_url_fopen is ENABLED. **Server-Side Request Forgery (SSRF) is possible** if file/URL functions are used.")
        found_vulnerabilities = True

    # Check 7: RFI
    if config['allow_url_include'].lower() == 'on' and config['allow_url_fopen'].lower() == 'on':
        print(f"[EXPLOIT PATH] allow_url_include AND allow_url_fopen are ENABLED. **Remote File Inclusion (RFI) for RCE is possible.**")
        found_vulnerabilities = True
        
    print("\n--- Analysis Complete ---")
    if found_vulnerabilities:
        print("!!! FOCUS POINT: Critical weaknesses detected. Prioritize the RCE and bypass vectors.")
    else:
        print("Configuration appears highly restrictive. Search for LFI/XXE or module-specific vulnerabilities.")


if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python phpinfo_analyzer.py <URL_TO_PHPINFO_PAGE>")
        print("Example: python phpinfo_analyzer.py https://10.10.10.10/info.php")
    else:
        target_url = sys.argv[1]
        fetch_and_analyze_phpinfo(target_url)
